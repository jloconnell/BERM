##set-up new pixels without ground-truth data (usually site level data) to predict the biophysical model outputs
##This script processes the landsat data (cloud and tide filter, get date/location etc.), estimates pixel flood proportion, 
##calculates atmospherically corrected Land Surface Temperature (LST), 
##calculates soil temperature from LST and Air temperature, and estimate the date of green up
###Version for running on the cluster 

##libraries
library(R.utils); library(caret); library(tidyverse);library(RColorBrewer); library(pls);
library(randomForest); library(data.table); library(raster); library(RcppRoll);

##output and save new models and data sets?? Set to True/False below. 
##Note that True will overwrite the existing models and output datasets, so you'll want a backup if you don't intend this
save_model<-FALSE
#save_model<-TRUE


##are we testing a small subset of the data?
small_test<-T

##set up files/objects to load into memory
#setwd("/work/demlab/jloconn/BERM")
#setwd("/home/jessica/remote/xfer/BERM")
setwd("/home/jessica/Documents/UGA/Projects/BERM")


##custom functions and models we need for this, uncomment if not already in memory
#source("functions/calc_indices_l8.r")
#source("functions/calc_lst_l8.r")
#source("functions/soil_temp_from_lst_and_air_lags.r")
#super_model <- readRDS("output/random_forest_flood_model_l8.rds")
#print(super_model)



##read in variables needed to atmospherically correct thermal data; 
##These were generated by the get_atmospheric_correction.r script
atm<-read.csv("output/atmospheric_correction_varsL8_gce.csv")
atm$date<-as.Date(atm$date)
atm<-atm[atm$date<"2019-08-01",]
tmp<-read.csv("output/atmospheric_correction_vars_L8820190801_20201004.csv")
tmp$date<-as.Date(tmp$date)
tmp<-dplyr::select(tmp, -lat, -long)
atm<-rbind(atm, tmp)
atm<-arrange(atm, date)

##read in elevation data as a spatial raster object
dem<-raster("data/ModDEM_ascii/mod_dem.txt")

###Read in Landsat8 observations for site level data to predict; This is created from the Google earth Engine Script
newpixels<-read_csv("data/L8_newpixels_small_2013_2020_noclouds.csv")
##process the landsat data to create needed time, date, and location columns
newpixels$time<-substr(newpixels$date,12,19)
newpixels$date<-as.Date(substr(newpixels$date,1,10))
newpixels$year<-as.numeric(format(newpixels$date, "%Y"))
newpixels$doy<-as.numeric(format(newpixels$date, "%j"))
newpixels$mo<-as.numeric(format(newpixels$date, "%m"))
newpixels$pix<-paste(newpixels$utm_east, newpixels$utm_north, sep="_")

if(small_test==T) {
  newpixels<-newpixels[newpixels$pix %in% c(unique(newpixels$pix)[1:150],unique(phenolocs$pix)),]
  }

##filter the landsat 8 data if needed through the pixel_qa landsat mask; 
##note that the current Landsat 8 Google Earth Engine script only returns cloud filtered data
##see https://landsat.usgs.gov/landsat-surface-reflectance-quality-assessment
##see https://newpixels.usgs.gov/newpixels-surface-reflectance-quality-assessment
newpixels$pixel_qa<-intToBin(newpixels$pixel_qa)
newpixels$qa_good<-ifelse(str_sub(newpixels$pixel_qa,-6,-1)=="000010",T,F) 
##"000010" from the right means no fill, yes clear, no water, no cloud shadow
## no water above is via Landsat 8's pixel qa mask, and misses a lot of marsh flooding in mixed pixels, we'll handle this below
## subset to only good pixels as indicated by the pixel_qa mask
newpixels<-newpixels[newpixels$qa_good==T,]

##pull lat longs from .geo column
x<-strsplit(newpixels$".geo", "\\[")
x<-sapply(x, "[[", 2)
x<-strsplit(x, "\\]")
x<-sapply(x, "[[", 1)
x<-strsplit(x, ",")
newpixels$long<-sapply(x, "[[", 1)
newpixels$lat<-sapply(x, "[[", 2)

##remove columns we don't need now from Landsat 8 Google Earth Engine data
newpixels<-dplyr::select(newpixels,-c(`system:index`,.geo, radsat_qa, sr_aerosol, pixel_qa, qa_good))
head(newpixels)

## Scale the landsat 8 bands to represent surface reflectance
newpixels$b1<-newpixels$B1*0.0001
newpixels$b2<-newpixels$B2*0.0001
newpixels$b3<-newpixels$B3*0.0001
newpixels$b4<-newpixels$B4*0.0001
newpixels$b5<-newpixels$B5*0.0001
newpixels$b6<-newpixels$B6*0.0001
newpixels$b7<-newpixels$B7*0.0001
##this is the needed scalar for these thermal bands: B10 and B11
newpixels$b10<-newpixels$B10*0.1
newpixels$b11<-newpixels$B11*0.1
##clean up columns to remove the ones we now don't need
newpixels<-dplyr::select(newpixels, -c(B1,B2,B3,B4,B5,B6,B7,B10,B11))

##negative reflectance values can occur at scene edges and should be removed
newpixels$b1<-ifelse(newpixels$b1<0,NA, newpixels$b1)
newpixels$b2<-ifelse(newpixels$b2<0,NA, newpixels$b2)
newpixels$b3<-ifelse(newpixels$b3<0,NA, newpixels$b3)
newpixels$b4<-ifelse(newpixels$b4<0,NA, newpixels$b4)
newpixels$b5<-ifelse(newpixels$b5<0,NA, newpixels$b5)
newpixels$b6<-ifelse(newpixels$b6<0,NA, newpixels$b6)
newpixels$b7<-ifelse(newpixels$b7<0,NA, newpixels$b7)
##filter to non-NA values
newpixels<-newpixels[is.na(newpixels$b1)==F,]; newpixels<-newpixels[is.na(newpixels$b7)==F,]
newpixels<-newpixels[is.na(newpixels$b5)==F,];newpixels<-newpixels[is.na(newpixels$b6)==F,]

###calculate a set of standard vegetation and spectral reflectance indices for landsat 8 data using our custom function
indices<-calc_index_l8(newpixels)
newpixels<-cbind(newpixels, indices)
newpixels$pix<-paste(newpixels$utm_east,newpixels$utm_north)
newpixels$ndmi<-(newpixels$b1-newpixels$b6)/(newpixels$b1+newpixels$b6) 
newpixels$pheno<-(newpixels$b4-newpixels$b6)/(newpixels$b4+newpixels$b6) ##from TMII paper
newpixels$doy<-as.numeric(format(newpixels$date, "%j"))

##calculate lst with custom function, first we need to merge in the atmospheric correction parameters
newpixels<-left_join(newpixels, atm, by="date")
newpixels$lst<-calc_lst(newpixels)


##create rolling pheno mean
##trick to get all dates, just create the full dates dataframe and merge it to the missing dates dataframe
y<-data.frame(date=seq.Date(from=min(newpixels$date, na.rm=T), to=max(newpixels$date, na.rm=T), by=1))
y<-expand.grid(date=y$date, pix=unique(newpixels$pix))
newpixels<-full_join(newpixels,y, all.y=TRUE)
newpixels<-arrange(newpixels, pix,date)

##this is an even window roll, because there's an observation for every day
newpixels<-newpixels %>% group_by(pix) %>% mutate(pheno2= roll_mean(pheno, n=30, na.rm=T,align="center", fill=NA))
newpixels<-newpixels[!is.na(newpixels$b2),]
newpixels<-newpixels[!is.na(newpixels$b5),]

newpixels<-arrange(newpixels, date)
newpixels$year<-as.numeric(format(newpixels$date, "%Y"))

##Predict pixelwise flooding with the flood model, set up variables in the right format first
newpixels$mo<-format(newpixels$date, "%m")
newpixels$mo<-ifelse(is.na(newpixels$mo),format(newpixels$landsat_date, "%m"), newpixels$mo)
newpixels$mo<-factor(newpixels$mo, levels=c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"))

newpixels$flooded <- predict(super_model, newdata=newpixels)
table(newpixels$date, newpixels$flooded)

newpixels$flooded<-as.numeric(newpixels$flooded)
newpixels$flooded<-ifelse(newpixels$flooded==1,0,newpixels$flooded)
newpixels$flooded<-ifelse(newpixels$flooded==2,1,newpixels$flooded)

##summarise flooded observation data by pixel, to get proportion of flooded observations by pixel
flood<- newpixels %>% dplyr::group_by(pix) %>% dplyr::summarise(flood_time= sum(as.numeric(flooded), na.rm=T)
                                                                /length(flooded[!is.na(flooded)]))

newpixels<-merge(newpixels, flood, by="pix", all.x=T)

##now that we know the flood_time for each pixel, we can subset to just dry observations for downstream analysis
newpixels<-newpixels[newpixels$flooded==0,]

##this last gets rid of dates with few satelitte obs.
if(small_test==F) {
    x<-table(newpixels$date);x<-x[x>1500]
  newpixels<-newpixels[newpixels$date %in% as.Date(names(x)),]
  }

##get elevation data
plot.locations<-data.frame(newpixels[,c("utm_east", "utm_north")])
plot.dem<-raster::extract(dem,plot.locations)
newpixels$elevation<-plot.dem


newpixels<-ungroup(newpixels)
newpixels<-newpixels[!is.na(newpixels$date),]
newpixels$mo<-as.numeric(format(newpixels$date, "%m"))
newpixels.heat.l8<-setup_heat(newpixels, gce=T)

if (save_model==T){
  write_csv(newpixels, "output/gce_pixels_landsat8_processed.csv")
  write_csv(newpixels.heat.l8, "output/gce_pixels_landsat8_greenup_via_lst_and_air_lags.csv")
}